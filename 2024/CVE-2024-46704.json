{
  "metadata": {
    "timestamp": "2025-02-22T16:11:19Z"
  },
  "data": [
    {
      "cve": {
        "id": "CVE-2024-46704",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nworkqueue: Fix spruious data race in __flush_work()\n\nWhen flushing a work item for cancellation, __flush_work() knows that it\nexclusively owns the work item through its PENDING bit. 134874e2eee9\n(\"workqueue: Allow cancel_work_sync() and disable_work() from atomic\ncontexts on BH work items\") added a read of @work-\u003edata to determine whether\nto use busy wait for BH work items that are being canceled. While the read\nis safe when @from_cancel, @work-\u003edata was read before testing @from_cancel\nto simplify code structure:\n\n\tdata = *work_data_bits(work);\n\tif (from_cancel \u0026\u0026\n\t    !WARN_ON_ONCE(data \u0026 WORK_STRUCT_PWQ) \u0026\u0026 (data \u0026 WORK_OFFQ_BH)) {\n\nWhile the read data was never used if !@from_cancel, this could trigger\nKCSAN data race detection spuriously:\n\n  ==================================================================\n  BUG: KCSAN: data-race in __flush_work / __flush_work\n\n  write to 0xffff8881223aa3e8 of 8 bytes by task 3998 on cpu 0:\n   instrument_write include/linux/instrumented.h:41 [inline]\n   ___set_bit include/asm-generic/bitops/instrumented-non-atomic.h:28 [inline]\n   insert_wq_barrier kernel/workqueue.c:3790 [inline]\n   start_flush_work kernel/workqueue.c:4142 [inline]\n   __flush_work+0x30b/0x570 kernel/workqueue.c:4178\n   flush_work kernel/workqueue.c:4229 [inline]\n   ...\n\n  read to 0xffff8881223aa3e8 of 8 bytes by task 50 on cpu 1:\n   __flush_work+0x42a/0x570 kernel/workqueue.c:4188\n   flush_work kernel/workqueue.c:4229 [inline]\n   flush_delayed_work+0x66/0x70 kernel/workqueue.c:4251\n   ...\n\n  value changed: 0x0000000000400000 -\u003e 0xffff88810006c00d\n\nReorganize the code so that @from_cancel is tested before @work-\u003edata is\naccessed. The only problem is triggering KCSAN detection spuriously. This\nshouldn't need READ_ONCE() or other access qualifiers.\n\nNo functional changes.",
        "metadata": {
          "published_date": "2024-09-13T07:15:05.397",
          "last_modified_date": "2024-09-19T13:32:39.257",
          "confidence_level": "low",
          "severity": "medium"
        },
        "impact": {
          "cisa_kev": false,
          "reported_exploited": false,
          "exploit_maturity": "none",
          "automatable": false
        },
        "counts": {
          "public_exploit_count": 0
        },
        "epss": {
          "score": 0.00043,
          "percentile": 0.11726
        },
        "metrics": [
          {
            "source": "nvd@nist.gov",
            "type": "Primary",
            "cvss_version": "3.1",
            "vector_string": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
            "attack_vector": "LOCAL",
            "base_score": 4.69999980926514
          }
        ],
        "timeline": {
          "references": [],
          "repositories": []
        }
      }
    }
  ]
}