{
  "metadata": {
    "timestamp": "2025-02-26T22:10:29Z"
  },
  "data": [
    {
      "cve": {
        "id": "CVE-2024-56786",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: put bpf_link's program when link is safe to be deallocated\n\nIn general, BPF link's underlying BPF program should be considered to be\nreachable through attach hook -\u003e link -\u003e prog chain, and, pessimistically,\nwe have to assume that as long as link's memory is not safe to free,\nattach hook's code might hold a pointer to BPF program and use it.\n\nAs such, it's not (generally) correct to put link's program early before\nwaiting for RCU GPs to go through. More eager bpf_prog_put() that we\ncurrently do is mostly correct due to BPF program's release code doing\nsimilar RCU GP waiting, but as will be shown in the following patches,\nBPF program can be non-sleepable (and, thus, reliant on only \"classic\"\nRCU GP), while BPF link's attach hook can have sleepable semantics and\nneeds to be protected by RCU Tasks Trace, and for such cases BPF link\nhas to go through RCU Tasks Trace + \"classic\" RCU GPs before being\ndeallocated. And so, if we put BPF program early, we might free BPF\nprogram before we free BPF link, leading to use-after-free situation.\n\nSo, this patch defers bpf_prog_put() until we are ready to perform\nbpf_link's deallocation. At worst, this delays BPF program freeing by\none extra RCU GP, but that seems completely acceptable. Alternatively,\nwe'd need more elaborate ways to determine BPF hook, BPF link, and BPF\nprogram lifetimes, and how they relate to each other, which seems like\nan unnecessary complication.\n\nNote, for most BPF links we still will perform eager bpf_prog_put() and\nlink dealloc, so for those BPF links there are no observable changes\nwhatsoever. Only BPF links that use deferred dealloc might notice\nslightly delayed freeing of BPF programs.\n\nAlso, to reduce code and logic duplication, extract program put + link\ndealloc logic into bpf_link_dealloc() helper.",
        "metadata": {
          "published": "",
          "last_modified": "",
          "confidence_level": "low",
          "severity": "high",
          "source": "",
          "status": ""
        },
        "impact": {
          "cisa_kev": false,
          "reported_exploited": false,
          "exploit_maturity": "none",
          "automatable": false
        },
        "metrics": [
          {
            "source": "134c704f-9b21-4f2e-91b3-4a467353bcc0",
            "type": "Secondary",
            "cvss_version": "3.1",
            "vector_string": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
            "attack_vector": "LOCAL",
            "base_score": 7.80000019073486
          },
          {
            "source": "nvd@nist.gov",
            "type": "Primary",
            "cvss_version": "3.1",
            "vector_string": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
            "attack_vector": "LOCAL",
            "base_score": 5.5
          }
        ],
        "timeline": {
          "references": null,
          "repositories": null
        },
        "epss": {
          "score": 0.00042,
          "percentile": 0.05018
        },
        "counts": {
          "public_exploit_count": 0
        }
      }
    }
  ]
}