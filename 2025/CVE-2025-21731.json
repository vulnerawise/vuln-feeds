{"metadata":{"timestamp":"2025-02-27T14:11:19Z"},"data":[{
      "cve": {
        "id": "CVE-2025-21731",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnbd: don't allow reconnect after disconnect\n\nFollowing process can cause nbd_config UAF:\n\n1) grab nbd_config temporarily;\n\n2) nbd_genl_disconnect() flush all recv_work() and release the\ninitial reference:\n\n  nbd_genl_disconnect\n   nbd_disconnect_and_put\n    nbd_disconnect\n     flush_workqueue(nbd-\u003erecv_workq)\n    if (test_and_clear_bit(NBD_RT_HAS_CONFIG_REF, ...))\n     nbd_config_put\n     -\u003e due to step 1), reference is still not zero\n\n3) nbd_genl_reconfigure() queue recv_work() again;\n\n  nbd_genl_reconfigure\n   config = nbd_get_config_unlocked(nbd)\n   if (!config)\n   -\u003e succeed\n   if (!test_bit(NBD_RT_BOUND, ...))\n   -\u003e succeed\n   nbd_reconnect_socket\n    queue_work(nbd-\u003erecv_workq, \u0026args-\u003ework)\n\n4) step 1) release the reference;\n\n5) Finially, recv_work() will trigger UAF:\n\n  recv_work\n   nbd_config_put(nbd)\n   -\u003e nbd_config is freed\n   atomic_dec(\u0026config-\u003erecv_threads)\n   -\u003e UAF\n\nFix the problem by clearing NBD_RT_BOUND in nbd_genl_disconnect(), so\nthat nbd_genl_reconfigure() will fail.",
        "metadata": {
          "published_date": "2025-02-27T02:15:16.833",
          "last_modified_date": "2025-02-27T02:15:16.833",
          "confidence_level": "low",
          "severity": ""
        },
        "impact": {
          "cisa_kev": false,
          "reported_exploited": false,
          "exploit_maturity": "none",
          "automatable": false
        },
        "counts": {
          "public_exploit_count": 0
        },
        "epss": {
          "score": 0,
          "percentile": 0
        },
        "timeline": {}
      }
    }]}