{"metadata":{"timestamp":"2025-02-27T18:15:03Z"},"data":[{
      "cve": {
        "id": "CVE-2022-49152",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nXArray: Fix xas_create_range() when multi-order entry present\n\nIf there is already an entry present that is of order \u003e= XA_CHUNK_SHIFT\nwhen we call xas_create_range(), xas_create_range() will misinterpret\nthat entry as a node and dereference xa_node-\u003eparent, generally leading\nto a crash that looks something like this:\n\ngeneral protection fault, probably for non-canonical address 0xdffffc0000000001:\n0000 [#1] PREEMPT SMP KASAN\nKASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f]\nCPU: 0 PID: 32 Comm: khugepaged Not tainted 5.17.0-rc8-syzkaller-00003-g56e337f2cf13 #0\nRIP: 0010:xa_parent_locked include/linux/xarray.h:1207 [inline]\nRIP: 0010:xas_create_range+0x2d9/0x6e0 lib/xarray.c:725\n\nIt's deterministically reproducable once you know what the problem is,\nbut producing it in a live kernel requires khugepaged to hit a race.\nWhile the problem has been present since xas_create_range() was\nintroduced, I'm not aware of a way to hit it before the page cache was\nconverted to use multi-index entries.",
        "metadata": {
          "published_date": "2025-02-26T07:00:52.440",
          "last_modified_date": "2025-02-26T07:00:52.440",
          "confidence_level": "low",
          "severity": ""
        },
        "impact": {
          "cisa_kev": false,
          "reported_exploited": false,
          "exploit_maturity": "none",
          "automatable": false
        },
        "counts": {
          "public_exploit_count": 0
        },
        "epss": {
          "score": 0,
          "percentile": 0
        },
        "timeline": {}
      }
    }]}